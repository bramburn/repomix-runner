import { Patch } from './types.js';

/**
 * Parses the raw text input from the LLM and extracts patch instructions.
 * Expected format:
 * <apply_diff>
 * File: path/to/file.ext
 * <<<<<<< SEARCH
 * code...
 * =======
 * code...
 * >>>>>>> REPLACE
 * </apply_diff>
 */
export function parsePatches(input: string): Patch[] {
  const patches: Patch[] = [];

  // Regex to find all <apply_diff> blocks (dotAll mode to capture newlines)
  const diffBlockRegex = /<apply_diff>([\s\S]*?)<\/apply_diff>/g;
  
  // Regex to extract the file path
  // Looks for "File:" followed by any whitespace and then the path until end of line
  const fileRegex = /File:\s*(.*)/;

  // Regex to extract SEARCH and REPLACE blocks
  // Captures content between the markers. 
  // We use [\s\S]*? for non-greedy matching across lines.
  const blockRegex = /<<<<<<<\s*SEARCH\s*([\s\S]*?)=======\s*([\s\S]*?)>>>>>>>\s*REPLACE/g;

  let blockMatch;
  while ((blockMatch = diffBlockRegex.exec(input)) !== null) {
    const diffContent = blockMatch[1];

    // Extract File Path
    const fileMatch = fileRegex.exec(diffContent);
    if (!fileMatch) {
      continue; // Skip blocks without a valid file definition
    }
    const filePath = fileMatch[1].trim();

    // Extract all Search/Replace pairs within this file block
    let pairMatch;
    while ((pairMatch = blockRegex.exec(diffContent)) !== null) {
      const searchContent = sanitizeContent(pairMatch[1]);
      const replaceContent = sanitizeContent(pairMatch[2]);

      patches.push({
        filePath,
        searchContent,
        replaceContent
      });
    }
  }

  return patches;
}

/**
 * Sanitizes the extracted content blocks.
 * LLMs often add a newline immediately after <<<<<<< SEARCH or before =======.
 * We trim the very first and very last newline if they exist, but preserve 
 * internal indentation and spacing.
 */
function sanitizeContent(content: string): string {
  // Remove strict specific leading/trailing newline generated by the block format
  // but keep the indentation of the code lines.
  let cleaned = content;
  
  if (cleaned.startsWith('\n')) {
    cleaned = cleaned.slice(1);
  }
  if (cleaned.endsWith('\n')) {
    cleaned = cleaned.slice(0, -1);
  }
  
  return cleaned;
}